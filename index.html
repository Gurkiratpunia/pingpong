<!-- (same header as your original file) -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Hand-Slap Table Tennis 3D</title>
    <!-- MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --neon-cyan: #00f0ff;
            --neon-pink: #ff2dd7;
            --neon-yellow: #ffe600;
            --bg-dark: #0a0a10;
            --overlay-bg: rgba(10, 10, 16, 0.9);
        }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-dark);
            color: white;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0, 240, 255, 0.15);
            border: 1px solid #333;
            background: radial-gradient(circle at center, #1a1a24 0%, #000000 100%);
            max-width: 100%; max-height: 100%;
        }

        /* UI Layer */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px; box-sizing: border-box;
        }

        .top-bar {
            display: flex; justify-content: space-between; align-items: flex-start;
            pointer-events: auto;
        }

        /* Score & Timer */
        .game-stats {
            display: flex; flex-direction: column; align-items: center; gap: 10px;
        }

        .timer-box {
            font-size: 2.5rem; font-weight: bold;
            color: var(--neon-yellow);
            text-shadow: 0 0 15px var(--neon-yellow);
            border: 2px solid var(--neon-yellow);
            padding: 5px 20px;
            border-radius: 8px;
            background: rgba(0,0,0,0.5);
        }

        .score-board {
            display: flex; gap: 40px; font-size: 2.5rem; font-weight: 800;
            text-shadow: 0 0 10px currentColor;
        }
        .score-p1 { color: var(--neon-cyan); }
        .score-p2 { color: var(--neon-pink); }
        .score-label { font-size: 0.8rem; color: #888; text-transform: uppercase; text-align: center;}

        /* Controls */
        .controls-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px; border-radius: 10px;
            border: 1px solid #444;
            text-align: right;
            backdrop-filter: blur(5px);
            display: flex; flex-direction: column; gap: 8px;
        }

        input[type=range] { width: 150px; accent-color: var(--neon-cyan); }

        .btn {
            background: transparent; border: 2px solid var(--neon-cyan);
            color: var(--neon-cyan); padding: 6px 12px;
            font-weight: bold; text-transform: uppercase;
            cursor: pointer; transition: all 0.2s; font-size: 0.8rem;
        }
        .btn:hover { background: var(--neon-cyan); color: #000; box-shadow: 0 0 15px var(--neon-cyan); }

        .btn-music { border-color: var(--neon-yellow); color: var(--neon-yellow); }
        .btn-music:hover { background: var(--neon-yellow); }
        .btn-music.active { background: var(--neon-yellow); color: black; box-shadow: 0 0 10px var(--neon-yellow); }

        .btn-reset { border-color: #ff4444; color: #ff4444; margin-top: 5px;}
        .btn-reset:hover { background: #ff4444; color: white; box-shadow: 0 0 15px #ff4444; }

        /* Overlays */
        .modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--overlay-bg);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; backdrop-filter: blur(8px); transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; }

        h1 {
            font-size: 3.5rem; margin: 0 0 20px 0; color: white;
            text-transform: uppercase; letter-spacing: 4px;
            text-shadow: 0 0 20px var(--neon-cyan); text-align: center;
        }
        h2 { font-size: 1.5rem; color: #ddd; margin-bottom: 30px; font-weight: 300; }

        .result-msg { font-size: 4rem; font-weight: 900; margin-bottom: 10px; }
        .win-cyan { color: var(--neon-cyan); text-shadow: 0 0 30px var(--neon-cyan); }
        .win-pink { color: var(--neon-pink); text-shadow: 0 0 30px var(--neon-pink); }
        .draw { color: var(--neon-yellow); text-shadow: 0 0 30px var(--neon-yellow); }

        #camera-preview {
            position: absolute; bottom: 20px; left: 20px; width: 120px; height: 90px;
            border: 2px solid #333; border-radius: 8px; transform: scaleX(-1);
            opacity: 0.8; background: black; object-fit: cover;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <video id="camera-preview" playsinline muted></video>

    <!-- UI -->
    <div class="ui-layer">
        <div class="top-bar">
            <div class="game-stats">
                <div class="timer-box" id="timerDisplay">60</div>
                <div class="score-board">
                    <div><div class="score-p1" id="scoreP1">0</div><div class="score-label">YOU</div></div>
                    <div><div class="score-p2" id="scoreP2">0</div><div class="score-label">CPU</div></div>
                </div>
            </div>

            <div class="controls-panel">
                <div style="color:#ccc; font-size:0.8rem; margin-bottom:2px;">Sensitivity</div>
                <input type="range" id="sensitivity" min="0.6" max="3.0" step="0.1" value="1.6">
                <button id="btn-music" class="btn btn-music">Music: OFF</button>
                <button id="btn-reset" class="btn btn-reset">Reset Game</button>
                <div id="debug-info" style="font-family:monospace; font-size:10px; color:#0f0; margin-top:5px; display:none;">
                    V: <span id="dbg-v">0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="modal-overlay">
        <h1>Neon Slap<br>Tennis 3D</h1>
        <h2>1 Minute Timer â€¢ Highest Score Wins</h2>
        <button id="btn-start" class="btn" style="font-size: 1.5rem; padding: 15px 40px;" disabled>Loading AI...</button>
        <p style="margin-top:20px; color: var(--neon-pink);" id="loading-msg">Initializing...</p>
    </div>

    <!-- End Screen -->
    <div id="end-screen" class="modal-overlay hidden">
        <div id="end-title" class="result-msg">GAME OVER</div>
        <h2 id="end-subtitle">Score: 0 - 0</h2>
        <button id="btn-play-again" class="btn" style="font-size: 1.2rem; padding: 10px 30px;">Play Again</button>
    </div>
</div>

<script>
/* 
 * CONFIGURATION 
 */
const CONFIG = {
    targetTime: 60, // Seconds
    gravity: 0.25,
    bounceDamping: 0.85,
    colors: { cyan: '#00f0ff', pink: '#ff2dd7', white: '#ffffff', yellow: '#ffe600' }
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const CANVAS_WIDTH = 1280;
const CANVAS_HEIGHT = 720;

// Game State
let gameState = 0; // 0: Menu, 1: Playing, 2: End
let timer = CONFIG.targetTime;
let lastTime = 0;
let scores = { p1: 0, p2: 0 };
let particles = [];

// Input State
let handData = { x: 0.5, y: 0.5, vx: 0, lastX: 0.5, lastY: 0.5, lastT: 0, present: false };
let slapCooldown = 0;
let keys = { ArrowUp: false, ArrowDown: false, Space: false };

// Objects
const paddleLeft = { x: 60, y: 360, w: 20, h: 120, color: CONFIG.colors.cyan, targetY: 360 };
const paddleRight = { x: CANVAS_WIDTH - 60, y: 360, w: 20, h: 120, color: CONFIG.colors.pink };
// Added prev positions to ball for continuous collision detection
const ball = { x: 640, y: 360, z: 200, vx: 0, vy: 0, vz: 0, radius: 12, prevX: 640, prevY: 360, prevZ: 200 };

/*
 * AUDIO SYSTEM (Music & SFX)
 */
const AudioSys = (function() {
    let ctx = null;
    let musicEnabled = false;
    let musicInterval = null;
    let beatCount = 0;

    function init() {
        if(!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
    }

    function playTone(freq, type, duration, vol=0.1, slide=0) {
        if(!ctx) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        if(slide) osc.frequency.linearRampToValueAtTime(freq + slide, ctx.currentTime + duration);
        gain.gain.setValueAtTime(vol, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
        osc.start();
        osc.stop(ctx.currentTime + duration);
    }

    function playNoise(duration) {
        if(!ctx) return;
        const bufferSize = ctx.sampleRate * duration;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.1, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
        
        noise.connect(gain);
        gain.connect(ctx.destination);
        noise.start();
    }

    // Procedural Music Sequencer (130 BPM)
    function stepSequencer() {
        if (!musicEnabled) return;
        const time = ctx.currentTime;
        const step = beatCount % 16; // 16 step loop

        // Kick (4/4)
        if (step % 4 === 0) {
            playTone(150, 'sine', 0.1, 0.4, -100); // Kick drum
        }
        
        // Hi-hat (Every off beat or 16th)
        if (step % 2 !== 0) {
            playNoise(0.05); // Closed hat
        }

        // Bass (Driving synth)
        // Pattern: Root notes pulsing
        if ([0,2,3, 6,8, 11,14].includes(step)) {
             // Simple arpeggio logic
             let freq = (step < 8) ? 110 : 110 * 1.5; // A2 -> E3
             playTone(freq, 'sawtooth', 0.1, 0.08);
        }

        beatCount++;
    }

    return {
        startMusic: () => {
            init();
            if(ctx.state === 'suspended') ctx.resume();
            if(musicInterval) clearInterval(musicInterval);
            // 130 BPM = ~461ms per beat, 16th notes = ~115ms
            musicInterval = setInterval(stepSequencer, 115);
            musicEnabled = true;
        },
        stopMusic: () => {
            musicEnabled = false;
            if(musicInterval) clearInterval(musicInterval);
        },
        toggleMusic: () => {
            musicEnabled = !musicEnabled;
            if(musicEnabled) {
                AudioSys.startMusic();
                return true;
            } else {
                AudioSys.stopMusic();
                return false;
            }
        },
        sfxHit: () => playTone(300, 'triangle', 0.1, 0.2, 400),
        sfxBounce: () => playTone(100, 'sine', 0.05, 0.2),
        sfxScore: () => playTone(600, 'square', 0.3, 0.1, 200),
        sfxOver: () => {
             // Win jingle
             [0, 150, 300].forEach(delay => {
                 setTimeout(() => playTone(440 + delay, 'sine', 0.4, 0.2), delay);
             });
        }
    };
})();

/*
 * MEDIA PIPE HANDS
 */
const videoElement = document.getElementById('camera-preview');
const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

hands.onResults((results) => {
    const now = performance.now();
    const dt = (now - handData.lastT) / 1000;
    handData.lastT = now;

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        handData.present = true;
        const lm = results.multiHandLandmarks[0];
        // 9 is middle finger MCP (stable center)
        let rx = 1.0 - lm[9].x; // Mirror
        let ry = lm[9].y;

        if (dt > 0) {
            let vx = (rx - handData.lastX) / dt;
            handData.vx = handData.vx * 0.5 + vx * 0.5; // Smooth
        }
        handData.lastX = rx; 
        handData.lastY = ry;
        paddleLeft.targetY = ry * CANVAS_HEIGHT;
        
        // Debug
        document.getElementById('dbg-v').innerText = handData.vx.toFixed(2);
    } else {
        handData.present = false;
    }
});

const camera = new Camera(videoElement, {
    onFrame: async () => { await hands.send({image: videoElement}); },
    width: 640, height: 480
});

/*
 * GAME LOGIC
 */
function spawnParticles(x, y, color) {
    for(let i=0; i<12; i++) {
        particles.push({
            x, y, vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12,
            life: 1, color
        });
    }
}

function resetRound(server) {
    ball.x = CANVAS_WIDTH/2; ball.y = CANVAS_HEIGHT/2; ball.z = 200;
    ball.prevX = ball.x; ball.prevY = ball.y; ball.prevZ = ball.z;
    ball.vx = (server === 'p1' ? 4 : -4);
    ball.vy = (Math.random()-0.5)*4; ball.vz = 0;
}

function resetGame() {
    scores = { p1: 0, p2: 0 };
    timer = CONFIG.targetTime;
    gameState = 1; // Playing
    document.getElementById('scoreP1').innerText = 0;
    document.getElementById('scoreP2').innerText = 0;
    document.getElementById('end-screen').classList.add('hidden');
    document.getElementById('start-screen').classList.add('hidden');
    resetRound('p1');
}

function endGame() {
    gameState = 2;
    AudioSys.sfxOver();
    const endTitle = document.getElementById('end-title');
    const endSub = document.getElementById('end-subtitle');
    
    if (scores.p1 > scores.p2) {
        endTitle.innerHTML = "YOU WON!";
        endTitle.className = "result-msg win-cyan";
    } else if (scores.p2 > scores.p1) {
        endTitle.innerHTML = "YOU LOST!";
        endTitle.className = "result-msg win-pink";
    } else {
        endTitle.innerHTML = "DRAW!";
        endTitle.className = "result-msg draw";
    }
    
    endSub.innerText = `Final Score: ${scores.p1} - ${scores.p2}`;
    document.getElementById('end-screen').classList.remove('hidden');
}

function update(dt) {
    if (gameState !== 1) return;

    // Timer
    timer -= dt;
    if (timer <= 0) {
        timer = 0;
        endGame();
    }
    // Format Timer 00:00
    let secs = Math.ceil(timer);
    let fmt = secs < 10 ? `00:0${secs}` : `00:${secs}`;
    let timerEl = document.getElementById('timerDisplay');
    timerEl.innerText = fmt;
    timerEl.style.color = secs <= 10 ? '#ff4444' : CONFIG.colors.yellow;
    timerEl.style.borderColor = secs <= 10 ? '#ff4444' : CONFIG.colors.yellow;

    // --- Player Input ---
    let slapDetected = false;
    if (handData.present) {
        paddleLeft.y += (paddleLeft.targetY - paddleLeft.y) * 0.2;
        let sens = parseFloat(document.getElementById('sensitivity').value);
        if (handData.vx > sens && slapCooldown <= 0) {
            slapDetected = true;
            slapCooldown = 0.3; // Seconds
        }
    } else {
        if (keys.ArrowUp) paddleLeft.y -= 10;
        if (keys.ArrowDown) paddleLeft.y += 10;
        if (keys.Space && slapCooldown <= 0) {
            slapDetected = true;
            slapCooldown = 0.3;
        }
    }
    paddleLeft.y = Math.max(60, Math.min(CANVAS_HEIGHT-60, paddleLeft.y));
    if (slapCooldown > 0) slapCooldown -= dt;

    // --- AI ---
    let aiTarget = ball.y;
    // AI Error/Latency
    if (ball.vx < 0) aiTarget = CANVAS_HEIGHT/2; // Center when ball moving away
    let aiSpeed = 0.08 + (scores.p1 * 0.005); // Get harder
    paddleRight.y += (aiTarget - paddleRight.y) * aiSpeed;
    paddleRight.y = Math.max(60, Math.min(CANVAS_HEIGHT-60, paddleRight.y));

    // Save previous position for continuous collision detection
    ball.prevX = ball.x;
    ball.prevY = ball.y;
    ball.prevZ = ball.z;

    // --- Physics ---
    ball.vz -= CONFIG.gravity;
    ball.z += ball.vz;
    ball.x += ball.vx;
    ball.y += ball.vy;

    // Bounce Ground
    if (ball.z < 0) {
        ball.z = 0;
        ball.vz = -ball.vz * CONFIG.bounceDamping;
        if (Math.abs(ball.vz) > 1) AudioSys.sfxBounce();
        if (Math.abs(ball.vz) < 1) ball.vz = 0;
    }
    // Bounce Walls
    if (ball.y < 0 || ball.y > CANVAS_HEIGHT) {
        ball.vy *= -1;
        ball.y = Math.max(0, Math.min(CANVAS_HEIGHT, ball.y));
        AudioSys.sfxBounce();
    }

    // --- Continuous Collisions ---
    // We'll detect if the ball's swept path crosses the paddle plane this frame.
    // Player paddle collision (left)
    const padLeftPlaneX = paddleLeft.x + 10; // right face of left paddle
    const padLeftMinY = paddleLeft.y - 60;
    const padLeftMaxY = paddleLeft.y + 60;
    const collisionZThreshold = 80; // allow more forgiving detection in z

    // If ball moved across the paddle plane this frame (and is moving toward it)
    if (ball.vx < 0) { // ball moving left -> toward player's left paddle
        const prevRight = ball.prevX - ball.radius;
        const currRight = ball.x - ball.radius;
        // Crossed the plane if previously strictly right of the plane and now at/left of it
        if (prevRight > padLeftPlaneX && currRight <= padLeftPlaneX && ball.z < collisionZThreshold) {
            // Check vertical overlap at collision moment (approximate using current Y)
            if (Math.abs(ball.y - paddleLeft.y) < 80) {
                // Resolve collision: place ball at contact and reflect velocity
                ball.x = padLeftPlaneX + ball.radius + 1; // nudge out to the right
                // Add slap boost if detected
                let boost = slapDetected ? 5 : 0;
                // Ensure outgoing velocity is positive (to the right)
                ball.vx = Math.abs(ball.vx) + 2 + boost;
                if (ball.vx > 25) ball.vx = 25;
                // add vertical deflection based on hit point
                let offset = (ball.y - paddleLeft.y) / 60;
                ball.vy += offset * 5;
                AudioSys.sfxHit();
                spawnParticles(ball.x, ball.y, CONFIG.colors.cyan);
            }
        }
    } else if (ball.vx > 0) {
        // AI paddle collision (right)
        const padRightPlaneX = paddleRight.x - 10; // left face of right paddle
        const prevLeft = ball.prevX + ball.radius;
        const currLeft = ball.x + ball.radius;
        if (prevLeft < padRightPlaneX && currLeft >= padRightPlaneX && ball.z < collisionZThreshold) {
            if (Math.abs(ball.y - paddleRight.y) < 80) {
                ball.x = padRightPlaneX - ball.radius - 1; // nudge out to the left
                ball.vx = -Math.abs(ball.vx) - 2;
                let offset = (ball.y - paddleRight.y) / 60;
                ball.vy += offset * 5;
                AudioSys.sfxHit();
                spawnParticles(ball.x, ball.y, CONFIG.colors.pink);
            }
        }
    }

    // --- Scoring ---
    if (ball.x < -50) {
        scores.p2++;
        document.getElementById('scoreP2').innerText = scores.p2;
        AudioSys.sfxScore();
        resetRound('p1');
    } else if (ball.x > CANVAS_WIDTH + 50) {
        scores.p1++;
        document.getElementById('scoreP1').innerText = scores.p1;
        AudioSys.sfxScore();
        resetRound('p2');
    }

    // Particles
    for(let i=particles.length-1; i>=0; i--) {
        particles[i].x += particles[i].vx;
        particles[i].y += particles[i].vy;
        particles[i].life -= 0.05;
        if(particles[i].life <= 0) particles.splice(i,1);
    }
}

function draw() {
    // Clear & BG
    ctx.fillStyle = '#0a0a10';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Grid
    ctx.strokeStyle = '#1f1f30'; ctx.lineWidth = 1;
    for(let i=0; i<CANVAS_HEIGHT; i+=40) { ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(CANVAS_WIDTH,i); ctx.stroke(); }
    for(let i=0; i<CANVAS_WIDTH; i+=40) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,CANVAS_HEIGHT); ctx.stroke(); }
    
    // Center Line
    ctx.strokeStyle = CONFIG.colors.cyan; ctx.globalAlpha = 0.2;
    ctx.beginPath(); ctx.moveTo(CANVAS_WIDTH/2, 0); ctx.lineTo(CANVAS_WIDTH/2, CANVAS_HEIGHT); ctx.stroke();
    ctx.globalAlpha = 1.0;

    // Particles
    particles.forEach(p => {
        ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
        ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
    });
    ctx.globalAlpha = 1.0;

    // Paddles (Neon Rects)
    const drawPad = (x,y,c) => {
        ctx.shadowBlur = 20; ctx.shadowColor = c; ctx.strokeStyle = c; ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath(); ctx.rect(x-10, y-60, 20, 120); ctx.fill(); ctx.stroke();
        ctx.shadowBlur = 0;
    };
    drawPad(paddleLeft.x, paddleLeft.y, CONFIG.colors.cyan);
    drawPad(paddleRight.x, paddleRight.y, CONFIG.colors.pink);

    // Ball (Pseudo 3D)
    // Shadow
    let sScale = 1 - Math.min(ball.z/300, 0.8);
    ctx.fillStyle = `rgba(0,240,255,${0.4*sScale})`;
    ctx.beginPath(); ctx.ellipse(ball.x, ball.y, ball.radius*1.5*sScale, ball.radius*0.5*sScale, 0, 0, Math.PI*2); ctx.fill();

    // Body
    let bY = ball.y - ball.z;
    let bScale = 1 + ball.z * 0.002;
    ctx.translate(ball.x, bY); ctx.scale(bScale, bScale);
    ctx.shadowBlur = 20; ctx.shadowColor = CONFIG.colors.cyan;
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0,0, ball.radius, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = 'rgba(0,240,255,0.3)'; ctx.fill();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.shadowBlur = 0;
}

/* 
 * LOOP & EVENTS 
 */
function loop(now) {
    requestAnimationFrame(loop);
    let dt = (now - lastTime) / 1000;
    lastTime = now;
    if(dt > 0.1) dt = 0.1; // Cap lag
    update(dt);
    draw();
}

// Event Listeners
document.getElementById('btn-start').addEventListener('click', async () => {
    try { await camera.start(); } catch(e) { console.log('Cam fail, using keys'); }
    resetGame();
});

document.getElementById('btn-play-again').addEventListener('click', resetGame);

document.getElementById('btn-reset').addEventListener('click', () => {
    resetGame();
    document.getElementById('btn-reset').blur(); // Remove focus
});

document.getElementById('btn-music').addEventListener('click', (e) => {
    const isOn = AudioSys.toggleMusic();
    e.target.innerText = isOn ? "Music: ON" : "Music: OFF";
    e.target.classList.toggle('active', isOn);
    e.target.blur();
});

window.addEventListener('keydown', e => { if(keys.hasOwnProperty(e.code)) keys[e.code] = true; });
window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.code)) keys[e.code] = false; });

// Init
setTimeout(() => {
    const btn = document.getElementById('btn-start');
    btn.innerText = "START GAME";
    btn.disabled = false;
    document.getElementById('loading-msg').style.display = 'none';
}, 1500);

canvas.width = CANVAS_WIDTH; canvas.height = CANVAS_HEIGHT;
loop(0);

</script>
</body>
</html>
